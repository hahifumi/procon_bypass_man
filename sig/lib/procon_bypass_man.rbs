# TypeProf 0.12.0

# Global variables
$will_interval_1_6: Float | Integer
$will_terminate_token: false
$will_interval_0_0_0_5: Float | Integer

# Classes
module ProconBypassMan
  VERSION: String
  @@logger: untyped
  @@root: untyped
  @@pid_path: String

  def self.configure: (?setting_path: nil) -> untyped
  def self.run: (?setting_path: nil) -> Integer
  def self.logger=: (untyped logger) -> untyped
  def self.logger: -> Logger
  def self.pid_path: -> String
  def self.reset!: -> Array[bot]
  def self.root: -> String?
  def self.root=: (untyped path) -> untyped
  def self.digest_path: -> String

  class Timer
    @timeout: Time

    def initialize: (?timeout: Time) -> Time
    def throw_if_timeout!: -> nil

    class Timeout < StandardError
    end
  end

  class Bypass
    attr_accessor gadget: untyped
    attr_accessor procon: untyped
    attr_accessor monitor: untyped
    def initialize: (gadget: untyped, procon: untyped, monitor: untyped) -> untyped
    def send_gadget_to_procon!: -> nil
    def send_procon_to_gadget!: -> nil
  end

  class DeviceConnector
    PROCON_PATH: String
    PROCON2_PATH: String
    @stack: Array[Value]
    @initialized_devices: bool
    @throw_error_if_timeout: bool
    @throw_error_if_mismatch: false
    @enable_at_exit: bool
    @gadget: untyped
    @procon: untyped

    def self.reset_connection!: -> DeviceConnector
    def self.connect: -> [nil, nil]
    def initialize: (?throw_error_if_timeout: bool, ?throw_error_if_mismatch: false, ?enable_at_exit: bool) -> bool
    def add: (Array[Regexp | [String]] values, read_from: :procon | :switch) -> Array[Value]
    def drain_all: -> nil
    def write_switch: (String data, ?only_write: false) -> true?
    def write_procon: (untyped data, ?only_write: false) -> ((Array[(Float | Integer | String)?] | true)?)
    def read_procon: (?only_read: false) -> nil
    def read_switch: (?only_read: false) -> nil
    def from_device: ((Array[Value] | Value)? item) -> nil
    def to_device: ((Array[Value] | Value)? item) -> nil
    def switch: -> nil
    def procon: -> nil
    def is_available_device?: (String path) -> bool
    def to_bin: (untyped string) -> untyped
    def init_devices: -> Proc?

    class BytesMismatchError < StandardError
    end

    class Value
      attr_accessor read_from: :procon | :switch
      attr_accessor values: Array[Regexp | [String]]
      def initialize: (values: Array[Regexp | [String]], read_from: :procon | :switch) -> (:procon | :switch)
    end
  end

  class Counter
    attr_accessor label: untyped
    attr_accessor table: Hash[bot, bot]
    attr_accessor previous_table: Hash[bot, bot]?
    def initialize: (label: untyped) -> Hash[bot, bot]
    def record: (untyped event_name) -> Counter
    def formated_previous_table: -> String
  end

  module IOMonitor
    @@list: Array[bot]

    def self.new: (label: untyped) -> Counter
    def self.targets: -> Array[bot]
    def self.start!: -> bot
    def self.reset!: -> Array[bot]
  end

  class Uptime
    def self.from_boot: -> Integer
  end

  class Runner
    @gadget: nil
    @procon: nil

    def initialize: -> Integer
    def run: -> bot

    private
    def main_loop: -> bot
    def first_negotiation: -> [nil, nil]
    def handle_signal: (untyped sig) -> nil
    def print_booted_message: -> nil

    class InterruptForRestart < StandardError
    end
  end

  class Processor
    @binary: untyped

    def initialize: (untyped binary) -> untyped
    def process: -> untyped
  end

  class Configuration
    MODES: [:manual]
    @prefix_keys_for_changing_layer: Array[bot]
    @@current_context_key: :main
    @@context: Hash[bot, bot]

    attr_accessor layers: {up: untyped, down: untyped, left: untyped, right: untyped}
    attr_accessor setting_path: bot
    attr_accessor mode_plugins: Hash[bot, bot]
    attr_accessor macro_plugins: Hash[bot, bot]
    attr_accessor context: untyped
    attr_accessor current_context_key: untyped
    def self.instance: -> Configuration
    def self.switch_new_context: (untyped key) -> untyped
    def initialize: -> {up: untyped, down: untyped, left: untyped, right: untyped}
    def layer: (untyped direction, ?mode: :manual) -> Configuration
    def install_mode_plugin: (untyped klass) -> Configuration
    def install_macro_plugin: (untyped klass) -> Configuration
    def prefix_keys_for_changing_layer: (untyped buttons) -> Configuration
    def prefix_keys: -> Array[bot]
    def reset!: -> {up: untyped, down: untyped, left: untyped, right: untyped}
  end

  class Procon
    @@status: {buttons: Hash[bot, bot], current_layer_key: :up, ongoing_macro: untyped, ongoing_mode: untyped}

    attr_accessor user_operation: untyped
    def self.reset!: -> {buttons: Hash[bot, bot], current_layer_key: :up, ongoing_macro: untyped, ongoing_mode: untyped}
    def initialize: (untyped binary) -> untyped
    def status: -> Hash[bot, bot]
    def ongoing_macro: -> untyped
    def ongoing_mode: -> untyped
    def current_layer_key: -> :up
    def current_layer: -> untyped
    def apply!: -> Hash[bot, bot]?
    def to_binary: -> untyped

    private
    def method_missing: (untyped name) -> untyped
  end

  class ProConRejected < StandardError
  end

  class CouldNotLoadConfigError < StandardError
  end

  class FirstConnectionError < StandardError
  end

  class EternalConnectionError < StandardError
  end
end
